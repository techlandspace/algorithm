### 排序算法
>含义：将一组数据，以指定的顺序进行排列的过程。

**排序的分类**：由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类。<br>
1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。
2. 外部排序，数据量过大，无法全部加载到内存中，需要借助外部存储进行排序

**按排序原理分类**:

```mermaid
graph LR
    %% 设置主题样式
    classDef title fill:#f6f8fa,stroke:#0366d6,stroke-width:2px,color:#24292e,font-weight:bold;
    classDef category fill:#eaf5ff,stroke:#79b8ff,stroke-width:1px,color:#0366d6,font-weight:bold;
    classDef subtype fill:#ffffff,stroke:#d0d7de,stroke-width:1px,color:#24292e;

    %% 顶层节点
    A[排序算法分类]:::title

    %% 一级分类
    A --> B(内部排序):::category
    A --> C(外部排序):::category

    %% 内部排序细分
    B --> D[插入排序]:::category
    B --> E[选择排序]:::category
    B --> F[交换排序]:::category
    B --> G[归并排序]:::category
    B --> H[基数排序]:::category

    %% 插入排序子类
    D --> D1[直接插入排序]:::subtype
    D --> D2[希尔排序]:::subtype

    %% 选择排序子类
    E --> E1[简单选择排序]:::subtype
    E --> E2[堆排序]:::subtype

    %% 交换排序子类
    F --> F1[冒泡排序]:::subtype
    F --> F2[快速排序]:::subtype

```

**排序算法比较**:<br>

|算法|时间复杂度(平均)|时间复杂度(最坏)|空间复杂度|稳定性|分类|
|:-:|:-:|:-:|:-:|:-:|:-:|
|**冒泡排序**|O(n²)|O(n²)|O(1)|稳定|交换排序|
|**选择排序**|O(n²)|O(n²)|O(1)|不稳定|选择排序|
|**插入排序**|O(n²)|O(n²)|O(1)|稳定|插入排序|
|**希尔排序**|O(n log n)|O(n²)|O(1)|不稳定|插入排序|
|**快速排序**|O(n log n)|O(n²)|O(log n)|不稳定|分治排序|
|**归并排序**|O(n log n)|O(n log n)|O(n)|稳定|分治排序|
|**堆排序**|O(n log n)|O(n log n)|O(1)|不稳定|选择排序|
|**计数排序**|O(n + k)|O(n + k)|O(k)|稳定|分布排序|
|**桶排序**|O(n + k)|O(n²)|O(n + k)|稳定|分布排序|
|**基数排序**|O(d(n + k))|O(d(n + k))|O(n + k)|稳定|分布排序|

